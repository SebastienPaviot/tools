<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Face Swap with OpenCV.js and NumJS</title>
  <script src="https://docs.opencv.org/3.4/opencv.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numjs/0.16.0/numjs.min.js"></script>
</head>
<body>
  <h1>Face Swap Demo v0.6</h1>
  <input type="file" id="sourceImage" accept="image/*" onchange="loadImage(event, 'source')">
  <input type="file" id="targetImage" accept="image/*" onchange="loadImage(event, 'target')">
  <canvas id="canvas" width="500" height="500"></canvas>

  <script>
    let sourceImg = new Image();
    let targetImg = new Image();
    let sourceFace, targetFace;

    function loadImage(event, type) {
  const file = event.target.files[0];
  const reader = new FileReader();

  reader.onload = function(e) {
    const img = new Image();
    img.src = e.target.result;
    
    img.onload = function() {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = img.width;
      tempCanvas.height = img.height;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      if (type === 'source') {
        sourceImg = tempCanvas;
        console.log(sourceImg);
      } else if (type === 'target') {
        targetImg = tempCanvas;
        console.log(targetImg);
      }
    };
  };
  reader.readAsDataURL(file);
}

    async function detectFaces() {
      console.log("detectfaces");
      console.log(sourceImg);
      const srcMat = cv.imread(sourceImg);
      console.log(srcMat);
      console.log(targetImg);
      const tgtMat = cv.imread(targetImg);
      console.log(tgtMat);
      const faceCascade = new cv.CascadeClassifier();
      await faceCascade.load('haarcascade_frontalface_default.xml');

      const srcGray = new cv.Mat();
      cv.cvtColor(srcMat, srcGray, cv.COLOR_RGBA2GRAY);
      const tgtGray = new cv.Mat();
      cv.cvtColor(tgtMat, tgtGray, cv.COLOR_RGBA2GRAY);

      const srcFaces = new cv.RectVector();
      const tgtFaces = new cv.RectVector();
      faceCascade.detectMultiScale(srcGray, srcFaces, 1.1, 3, 0);
      faceCascade.detectMultiScale(tgtGray, tgtFaces, 1.1, 3, 0);

      if (srcFaces.size() > 0 && tgtFaces.size() > 0) {
        sourceFace = srcFaces.get(0);
        targetFace = tgtFaces.get(0);
        swapFaces(srcMat, tgtMat);
      } else {
        console.error("No faces detected in one or both images.");
      }

      srcMat.delete(); tgtMat.delete(); srcGray.delete(); tgtGray.delete();
      srcFaces.delete(); tgtFaces.delete();
    }

    function swapFaces(srcMat, tgtMat) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = targetImg.width;
      canvas.height = targetImg.height;

      const sourceRoi = srcMat.roi(sourceFace);
      const targetRoi = tgtMat.roi(targetFace);

      const srcPoints = nj.array([
        [sourceFace.x, sourceFace.y],
        [sourceFace.x + sourceFace.width, sourceFace.y],
        [sourceFace.x, sourceFace.y + sourceFace.height]
      ]);

      const tgtPoints = nj.array([
        [targetFace.x, targetFace.y],
        [targetFace.x + targetFace.width, targetFace.y],
        [targetFace.x, targetFace.y + targetFace.height]
      ]);

      const transformationMatrix = calculateAffineTransform(srcPoints, tgtPoints);

      const warpMat = new cv.Mat();
      cv.warpAffine(sourceRoi, targetRoi, transformationMatrix, targetRoi.size());

      cv.imshow(canvas, tgtMat);

      sourceRoi.delete(); targetRoi.delete(); warpMat.delete();
    }

    function calculateAffineTransform(srcPoints, tgtPoints) {
      const srcMean = srcPoints.mean(0);
      const tgtMean = tgtPoints.mean(0);
      const centeredSrc = srcPoints.subtract(srcMean);
      const centeredTgt = tgtPoints.subtract(tgtMean);

      const rotationMatrix = centeredTgt.transpose().dot(centeredSrc).tolist();
      const [U, , V] = nj.linalg.svd(rotationMatrix);

      const rotation = nj.dot(U, V);
      const scale = tgtPoints.norm() / srcPoints.norm();
      const translation = tgtMean.subtract(nj.dot(rotation, srcMean).multiply(scale));

      const affine = nj.concatenate([rotation.multiply(scale), translation.reshape(2, 1)], 1);
      return cv.matFromArray(2, 3, cv.CV_64F, affine.flatten().tolist());
    }

    document.getElementById('targetImage').addEventListener('change', detectFaces);
  </script>
</body>
</html>
